<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://trojians.github.io</id>
    <title>Trojians</title>
    <updated>2019-05-31T00:59:36.179Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://trojians.github.io"/>
    <link rel="self" href="https://trojians.github.io/atom.xml"/>
    <subtitle>天青色等烟雨</subtitle>
    <logo>https://trojians.github.io/images/avatar.png</logo>
    <icon>https://trojians.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Trojians</rights>
    <entry>
        <title type="html"><![CDATA[神器网站&工具]]></title>
        <id>https://trojians.github.io/post/shen-qi-wang-zhan-andgong-ju</id>
        <link href="https://trojians.github.io/post/shen-qi-wang-zhan-andgong-ju">
        </link>
        <updated>2019-05-31T00:52:37.000Z</updated>
        <summary type="html"><![CDATA[<p>这篇文章收集的是各种神器网站&amp;工具以及其他</p>
]]></summary>
        <content type="html"><![CDATA[<p>这篇文章收集的是各种神器网站&amp;工具以及其他</p>
<!--more-->
<p><strong>工具类：</strong></p>
<ul>
<li>一个可以下载各大视频网站的网站解析神器（油管能解析，无法下载）
https://www.urlgot.com/zh_CN/</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[这是一个测试大神集中营的文章]]></title>
        <id>https://trojians.github.io/post/zhe-shi-yi-ge-ce-shi-da-shen-ji-zhong-ying-de-wen-zhang</id>
        <link href="https://trojians.github.io/post/zhe-shi-yi-ge-ce-shi-da-shen-ji-zhong-ying-de-wen-zhang">
        </link>
        <updated>2019-05-29T08:09:46.000Z</updated>
        <summary type="html"><![CDATA[<p>这是摘要这是摘要
这是摘要
这是摘要</p>
]]></summary>
        <content type="html"><![CDATA[<p>这是摘要这是摘要
这是摘要
这是摘要</p>
<!--more-->
<p>这是测试的正文这是测试的正文这是测试的正文这是测试的正文这是测试的正文这是测试的正文这是测试的正文这是测试的正文这是测试的正文这是测试的正文这是测试的正文这是测试的正文这是测试的正文这是测试的正文，这是测试的正文这是测试的正文这是测试的正文这是测试的正文这是测试的正文这是测试的正文。这是测试的正文这是测试的正文这是测试的正文这是测试的正文，这是测试的正文这是测试的正文这是测试的正文这是测试的正文这是测试的正文这是测试的正文。这是测试的正文这是测试的正文这是测试的正文，这是测试的正文这是测试的正文这是测试的正文这是测试的正文。这是测试的正文这是测试的正文这是测试的正文这是测试的正文这是测试的正文这是测试的正文这是测试的正文。这是测试的正文这是测试的正文这是测试的正文，这是测试的正文这是测试的正文这是测试的正文这是测试的正文。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[什么鬼？]]></title>
        <id>https://trojians.github.io/post/shi-me-gui</id>
        <link href="https://trojians.github.io/post/shi-me-gui">
        </link>
        <updated>2019-05-27T03:00:28.000Z</updated>
        <summary type="html"><![CDATA[<p>我就真的不清楚了</p>
]]></summary>
        <content type="html"><![CDATA[<p>我就真的不清楚了</p>
<!--more-->
<p>速度快</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[难道是这样？]]></title>
        <id>https://trojians.github.io/post/nan-dao-shi-zhe-yang</id>
        <link href="https://trojians.github.io/post/nan-dao-shi-zhe-yang">
        </link>
        <updated>2019-05-27T01:15:41.000Z</updated>
        <content type="html"><![CDATA[<p>trojians.github.io
master
trojians</p>
<p>625147795@qq.com</p>
<p>653f84239b406f6c6ff8d74b7d35f91ffa60bfc9</p>
<p>评论设置：</p>
<p>dd5d484034ef01484067</p>
<p>34cfb77bb806b90eb592c00116742d4c2ebc609f</p>
<p>trojians.github.io
trojians</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[元素错排重排]]></title>
        <id>https://trojians.github.io/post/yuan-su-cuo-pai-chong-pai</id>
        <link href="https://trojians.github.io/post/yuan-su-cuo-pai-chong-pai">
        </link>
        <updated>2019-02-23T01:42:33.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://trojians.github.io/post-images/1550886175730.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[隔年增长问题]]></title>
        <id>https://trojians.github.io/post/ge-nian-zeng-chang-wen-ti</id>
        <link href="https://trojians.github.io/post/ge-nian-zeng-chang-wen-ti">
        </link>
        <updated>2019-02-22T01:56:53.000Z</updated>
        <content type="html"><![CDATA[<p>隔年增长问题的概念及公式</p>
<p>隔年增长问题就是研究的数据中间往往间隔一年，去研究间隔一年后数据之间的关系，常见的考点有隔年基期、隔年增长量、隔年倍数的考查。在正式讲解之前，先要明白几个基本概念，分别是现期、间期、基期。
<img src="https://trojians.github.io/post-images/1550800672541.jpg" alt=""></p>
<p>【举例说明】2016年全国规模以上工业企业实现利润总额68803.2亿元，比上年增长8.5%，增速比上年提高10.8个百分点。</p>
<p>求:(1)2016年相较于2014年全国规模以上工业企业实现利润总额的同比增速是多少?</p>
<p>(2)2014年全国规模以上工业企业实现利润总额是多少?
<img src="https://trojians.github.io/post-images/1550801014509.jpg" alt="">
<img src="https://trojians.github.io/post-images/1550800709510.jpg" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[判断推理题]]></title>
        <id>https://trojians.github.io/post/pan-duan-tui-li-ti</id>
        <link href="https://trojians.github.io/post/pan-duan-tui-li-ti">
        </link>
        <updated>2019-02-21T08:22:11.000Z</updated>
        <content type="html"><![CDATA[<p>1.有些外科手术需要一种特殊类型的线带，使外科伤口缝合达到10天，这是外科伤口需要线带的最长时间。D型带是这种线带的一个新品种，D型带的销售人员声称D型带将会提高治疗功效，因为D型带的黏附时间是目前使用的线带的两倍长。</p>
<p>以下哪项如果为真，最能说明D型带销售人员的声明有漏洞?</p>
<p>A.大多数外科伤口愈合大约需要10天</p>
<p>B.大多数外科线带是从医院而不是从药店得到的</p>
<p>C.目前使用的线带的黏性足够使伤口缝合10天</p>
<p>D.现在还不清楚究竟是D型带还是目前使用的线带更有利于伤口的愈合</p>
<p>2.从所给的四个选项中，选择最合适的一个填入问号处，使之呈现一定的规律性。</p>
<p><img src="https://trojians.github.io/post-images/1550737652929.png" alt=""></p>
<p>判断推理题库</p>
<p>参考答案与解析</p>
<p>1.【答案】C。 解析：题干说明外科伤口需要线带最长时间为10天，如目前使用的线带已足够使伤口缝合10天，则销售人员所说的D型线带黏附时间是目前使用的两倍就没有意义，C项最能说明销售人员观点的漏洞。故答案选C。</p>
<p>2.【答案】D。 解析：所有字母的笔画数都是1，选项中只有D项符合。</p>
<p>3.【答案】C。 解析：从第二个图形开始，每个图形的外部图形为前一个图形的内部图形，只有C项的外部图形符合条件。</p>
<p>4.【答案】C。 解析：第一组图形的首位数字依次为7，6，5，包含的封闭区域数分别为0，1，2;第二组图形的首位数字依次为4，3，(2)，包含的封闭区域数分别为1，2，(3)。因此应选择封闭区域数为3，首位数字为2的图形，只有C项符合。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数量关系题]]></title>
        <id>https://trojians.github.io/post/shu-liang-guan-xi-ti</id>
        <link href="https://trojians.github.io/post/shu-liang-guan-xi-ti">
        </link>
        <updated>2019-02-21T03:01:51.000Z</updated>
        <content type="html"><![CDATA[<p>3.单独完成某项工作，甲需要16小时，乙需要12小时，如果按照甲、乙、甲、乙、……的顺序轮流工作，每次1小时，那么完成这项工作需要多长时间?</p>
<p>A.13小时40分钟 B.13小时45分钟</p>
<p>C.13小时50分钟 D.14小时</p>
<p>4.将A、B、C三个水管打开向水池放水，水池12分钟可以灌满;将B、C、D三个水管打开向水池放水，水池15分钟可以灌满;将A、D两个水管打开向水池放水，水池20分钟可以灌满。如果将A、B、C、D四个水管打开向水池放水，水池需多少分钟可以灌满?</p>
<p>A.25 B.20 C.15 D.10</p>
<p>解析：3、根据甲乙的单独完成工作时间设总工作量为48（即16 和12的最小公倍数），则甲的效率为3，乙的效率为4，一个循环甲乙共完成的工作量是3+4=7，6个循环12小时之后完成42，还剩6，甲再做1小时，剩余3，用时3÷4为45分钟，所以一共用时12+1+0.75小时。
4、设水池总量为60，设四个水管效率分别为A、B、C、D，则A+B+C=5，B+C+D=4，A+D=3。三式相加得2(A+B+C+D)=5+4+3=12，故四个水管的效率和为6，需要10分钟可将水池灌满。</p>
<p>1.刘师傅和张师傅比赛加工机器零件，每人加工300个，刘师傅每分钟加工2个，张师傅每加工10个零件比刘师傅少用20秒。问张师傅加工完300个零件时，刘师傅还有多少个零件没有加工?</p>
<p>A.20个 B.25个 C.30个 D.40个</p>
<p>2.文印室小王和小李6小时共打印了900页文件，小王打印的速度比小李快50%，请问小王每小时打印多少页文件?</p>
<p>A.60 B.70 C.80 D.90</p>
<p>3.一项工程进行m天之后，速度如果提高20%，则可以提前n天完工，问速度如果提高50%，则可以提前多少天完工?</p>
<p>A.2n B.2.5n C.2n+m D.2.5n+m</p>
<p>4.某项工程，小王单独做需15天完成，小张单独做需10天完成。现在两人合作，但中间小王休息了5天，小张也休息了若干天，最后该工程用11天完成。则小张休息的天数是( )。</p>
<p>A.6天 B.2天 C.3天 D.5天</p>
<p>参考答案与解析</p>
<p>1.【答案】A。解析：张师傅每加工10个零件比刘师傅少用20秒，所以加工完300个零件张师傅一共比刘师傅少用300÷10×20=600秒即10分钟，所以刘师傅还有10×2=20个零件没有加工。</p>
<p>2.【答案】D。解析：小王和小李每小时打印900÷6=150页，则小王每小时打印150÷(1+1.5)×1.5=90页。</p>
<p>3.【答案】A。解析：剩余的工作量一定，工作效率和工作时间成反比。速度提高20%，原速和现速之比为5∶6，所需时间之比为6∶5，少用一份时间相当于少用n天，一份代表n天，说明剩余工作按原来效率来干需要6n天。速度如果提高50%，原速和现速之比为2∶3，所需时间之比为3∶2，原来需要三份时间，需要6n天，一份时间为2n天，少用一份时间，少用2n天。因此答案选A。</p>
<p>4.【答案】D。解析：设工程总量为30，则小王的效率为2，小张的效率为3。两人合作，小王做了11-5=6天，完成工作2×6=12，剩下的工程量30-12=18由小张完成，需要18÷3=6天，因此小张休息的天数为11-6=5天，选择D。</p>
<p>1.甲乙两人分别从AB两地同时出发相向而行，不断往返于A、B两地之间，第一次相遇距离A地5千米，第二次相遇距离A地3千米，则A、B两地距离多少千米?</p>
<p>A.9 B.10 C.11 D.12</p>
<p>2.A大学的小李和B大学的小孙分别从自己学校同时出发，不断往返于A、B两校之间。现已知小李的速度为85米/分钟，小孙的速度为105米/分钟，且经过12分钟后两人第二次相遇。问A、B两校相距多少米?</p>
<p>A.1140 B.980 C.840 D.760</p>
<p>3.甲、乙两人在相距200米的直路上来回跑步，如果他们同时于6点05分分别在直路两端出发，当他们第二次相遇时，时间是6点07分，已知甲每秒比乙每秒多跑1米，则甲的速度是( )米/秒?</p>
<p>A.2 B.3 C.4 D.5</p>
<p>4.一只船顺流而行航速为50千米/小时，已知顺水航行3小时和逆水航行5小时的航程相等，则此船顺水漂流1小时的航程为( )千米。</p>
<p>A.8 B.10 C.12 D.15</p>
<p>参考答案与解析</p>
<p>1.【答案】A。 解析：根据多次相遇的公式，A、B两地距离为(3×5+3)÷2=9千米。选择A。</p>
<p>2.【答案】D。 解析：设A大学和B大学之间的距离为S，因为小孙和小李相遇两次，则两人走过的路程总共为3S，根据题意可得12×(85+105)=3S，解得S=760。</p>
<p>3.【答案】B。 解析：甲、乙二人从开始到第二次相遇用时2分，即120秒，二人走的总路程为200×(2×2-1)=600米，由此可得甲、乙两人的速度和为600÷120=5米/秒，结合“甲每秒比乙每秒多跑1米”可得甲的速度分别为3米/秒。</p>
<p>4.【答案】B。 解析：根据题意，顺水航行与逆水航行的速度之比为5∶3，则逆水航行的速度为30千米/小时，水流速度为(50-30)÷2=10千米/小时，此船顺水漂流1小时的航程为10×1=10千米，选B。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[正月十五]]></title>
        <id>https://trojians.github.io/post/zheng-yue-shi-wu</id>
        <link href="https://trojians.github.io/post/zheng-yue-shi-wu">
        </link>
        <updated>2019-02-19T07:17:15.000Z</updated>
        <content type="html"><![CDATA[<p>今天是2019年的2月19日，农历己亥年正月十五。
<img src="https://trojians.github.io/post-images/1550552543107.jpg" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[正则]]></title>
        <id>https://trojians.github.io/post/zhengze</id>
        <link href="https://trojians.github.io/post/zhengze">
        </link>
        <updated>2019-02-19T01:08:11.000Z</updated>
        <content type="html"><![CDATA[<p>@2019-1-4</p>
<h5 id="正则表达式的基础">正则表达式的基础</h5>
<p>什么是正则</p>
<blockquote>
<p>正则就是一个规则，用来处理<code>字符串</code>的规则</p>
<ol>
<li>正则匹配
编写一个规则，验证某个字符串是否符合这个规则，正则匹配使用的是test方法</li>
<li>正则捕获
编写一个规则，在一个字符串中把符合规则的内容都获取到，正则捕获使用的方法：正则的exec方法，字符串中的split、replace、math等方法都支持正则</li>
</ol>
<pre><code class="language-javascript">var reg = /^$/;//=&gt;两个斜杠之间包含一些内容就是正则，两个斜杠之间包含的全部内容都是元字符
</code></pre>
</blockquote>
<h5 id="正则中常用的元字符和修饰符汇总">正则中常用的元字符和修饰符汇总</h5>
<blockquote>
<p>任何一个正则都是由元字符和修饰符组成的</p>
<p><code>修饰符</code></p>
<p>g(global)：全局匹配</p>
<p>i(ignoreCase):或略大小写匹配</p>
<p>m(multiline):多行匹配</p>
<p><code>元字符</code></p>
<p>[量词元字符]</p>
<p>+：让前面的元字符出现一到多次</p>
<p>?：出现零到一次</p>
<p>*:出现零到多次</p>
<p>{n}:出现n次</p>
<p>{n,}:出现n到多次</p>
<p>{n,m}:出现n到m次</p>
<p>[特殊意义的元字符]</p>
<p>:转义字符（把一个普通字符转变为有特殊意义的字符，或者把一个有意义的字符转变为普通的字符）</p>
<p>.:除了\n（换行符）以外的任意字符</p>
<p>\d:匹配一个0-9之间的数字</p>
<p>\D:匹配任意一个非0-9之间的数字（大写字母和小写字母的组合是反向的）</p>
<p>\w:匹配一个0-9或字母或_之间的字符</p>
<p>\s:匹配一个任意空白字符</p>
<p>\b:匹配一个边界符</p>
<p>x|y:匹配x或者y中的一个</p>
<p>[a-z]:匹配a到z中的任意一个字符</p>
<p>[^a-z]: 和上面的相反，匹配任意一个非a-z的字符</p>
<p>[xyz]:匹配x或者y或者z中的任意字符</p>
<p>[^xyz]:匹配除了xyz以外的任意一个字符</p>
<p>():正则的小分组，匹配一个小分组 （小分组可以理解为大正则中的一个小正则）</p>
<p>^:以某一个元字符开始</p>
<p>$：以某一个元字符结束</p>
<p>?:：只匹配不捕获</p>
<p>?=:正向预查</p>
<p>?!:负向预查</p>
<p>...</p>
</blockquote>
<p>除了以上特殊元字符和量词元字符，其余的都叫做普通元字符：代表本身意义的元字符</p>
<h5 id="元字符详细解读">元字符详细解读</h5>
<p><code>^ $</code></p>
<pre><code class="language-javascript">var reg = /\d+/;//=&gt;包含某某某即可，这里说明只要包含1到多个数字即可
var str = '珠峰2017培训2018';
reg.test(str);//=&gt;true

reg = /^\d+/;
reg.test(str);//=&gt;false

reg = /^\d+$/;//=&gt;只能是某某某的，这里说明只能是1到多个数字
reg.test('2017');//=&gt;true
reg.test('2');//=&gt;true ^或者$只是一个修饰或者声明，不会占字符串的位置

</code></pre>
<p><code>\</code></p>
<pre><code class="language-javascript">var reg = /^2.3$/;
reg.test('2.3');//=&gt;true
reg.test('2+3');//=&gt;true 点在正则中的意思：匹配除了\n以外的任意字符，而不是单纯的小数点

var reg = /^2\.3$/;
reg.test('2.3');//=&gt;true
reg.test('2+3');//=&gt;false 使用转义字符把点转换为本身小数点的意思
</code></pre>
<p><code>x|y</code></p>
<pre><code class="language-javascript">var reg = /^18|19$/;//=&gt; 18 19 189 119 819 181 1819 ...很多都符合这个规则
/*
*18 或者19
*以1开头 以9 结尾 中间是8或者1 
*以18开头或者以19 结尾即可
*/

var reg = /^(18|19)$/;//=&gt;此时只有18或者19符合我们的规则
</code></pre>
<blockquote>
<p><code>()</code>：正则中的分组，也可以理解为一个大正则中的一个正则（包起来的部分是一个整体）；在正则中农我们可以使用小括号<code>改变默认的优先级</code></p>
<p>小分组还有第二个作用：<code>分组引用</code></p>
<p>小分组的第三个作用：<code>分组捕获</code></p>
<pre><code class="language-javascript">//=&gt;分组引用：\1或者\2...出现和地N个分组一模一样的内容
var reg = /^([a-z])([a-z])\2([a-z])$/;//=&gt;符合的字符串：foot、book、week、attr、http...
</code></pre>
</blockquote>
<p><code>[]</code></p>
<blockquote>
<p>[xyz][^zyx][a-z]</p>
<p>[^a-z]</p>
<pre><code class="language-javascript">//=&gt;\w:数组字母下划线中的任意一个字符
var reg = /^[a-zA-Z0-9]$/;//=&gt;等价于\w

//=&gt;中括号中出现的元字符，一般都代表本身的含义

var reg = /^[.?+&amp;]$/;//=&gt;里面的四个元字符都是本身的含义，例如：点就是小数点，不是所谓的任意字符...

//=&gt;需求：描述样式类名的规则（数字、字母、下划线、-，并且不能以-开头）
//var reg = /^[\w-]+$/;
//=&gt;或者
var reg = /^[a-zA-Z0-9_-]+$/;//=&gt;没有处理以-开头的情况
var reg = /^\w[\w-]*$/;//&lt;=&gt; /^\w[a-zA-Z0-9_-]*$/
</code></pre>
<pre><code class="language-javascript">//=&gt;需求：验证18~65之间的年龄
var reg = /^[18-65]$/;//=&gt;1或者8~6或者5中的任意一个字符，中括号中出现的18不是数字18，而是1或者8，当前正则是非法的：因为不能设置8~6这样的范围，只能从小打到，不能从大到小

//=&gt;分三个阶段处理：
//=&gt;18或者19
//=&gt;20~59
//=&gt;60~65

var reg= /^((18|19)|([2-5]\d)|(6[0-5]))$/;
</code></pre>
</blockquote>
<h5 id="常用正则表达式编写">常用正则表达式编写</h5>
<p><code>验证是否为有效数字</code></p>
<pre><code class="language-javascript">//=&gt;可能是整数、负数   12 -12 
//=&gt;整数或者小数  0 12 0.2 12.5 -12.3
//=&gt;只要出现小数点，后面至少要跟一位数字 
//=&gt;小数点前面必须有数字
var reg = /^-?(\d|([1-9]\d+))(\.\d+)?$/;

/*
*-? 负号可有可无
*(\d|([1-9]\d+))
*	\d 一位数可以是任何值
*	([1-9]\d+)多位数不能以0开头
*(\.\d+)? 小数部分可有可无，有点的话点后面必须跟一位数字
*/
</code></pre>
<p><code>手机号码</code></p>
<pre><code class="language-javascript">/*
*11位数字
*1开头
*/

var reg = /^1[0-9]{10}$/;//=&gt; &lt;=&gt; /^1\d{10}$/
</code></pre>
<p><code>用户名：真实姓名</code></p>
<pre><code class="language-javascript">//=&gt;/^[\u4e00-\u9fa5]$/ 中文汉字的正则
var reg = /^[\u4e00-\u9fa5]{2,10}(·[\u4e00-\u9fa5]{2,10})?$/
</code></pre>
<p><code>邮箱</code></p>
<pre><code class="language-javascript">var reg = /^\w+((-\w+)|(\.\w+))*@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/;
/*
*以数字、字母、下划线开头
*@前面可以是数字、字母、下划线、-、.这些符号
*不能把-和.连续出现，出现一次，后面必须跟数字、字母、下划线
*@后面的部分支持企业邮箱
*.com.cn多域名的情况
*/
//[A-Za-z0-9]+
//((\.|-)[A-Za-z0-9]+)*
//\.[A-Za-z0-9]+
</code></pre>
<p><code>身份证</code></p>
<pre><code class="language-javascript">/*
*18位
*前17位必须是数字
*最后一位可以是数字或者大写X（X代表10）
*130828199012040617
*前六位：省市县  130828
*接下来八位：出生年+月+日
*倒数第二位数字：奇数代表男 偶数代表女
*/
//=&gt;年 1950~2017
//=&gt;第一段：1950~1999  
//=&gt;第二段：2000~2017
//==&gt;00~09
//==&gt;10~17
//==&gt;/^((19[5-9]\d)|(20((0\d)|(1[0-7]))))$/
var reg = /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(\d|X)$/;
//=&gt;这样写不仅可以匹配，而且可以在捕获的时候，可以把大正则匹配的结果捕获到，里面的每一个小分组（小正则）匹配的结果也可以单独的捕获到“分组捕获”
</code></pre>
<h5 id="正则的捕获">正则的捕获</h5>
<blockquote>
<p>把当前字符串当中符合正则的字符捕获到</p>
<p>RegExp.prototype:<code>exec</code>实现正则捕获的方法</p>
</blockquote>
<pre><code class="language-javascript">var str = '珠峰培训2017扬帆起航2018';
var reg = /\d+/;

reg.exec(str);

/*
*当正则捕获的时候：
*1、先去验证当前字符串是否匹配，如果不匹配返回的结果是null（没有捕获到任何的内容）
*2、如果匹配，从字符串最左边开始，向右查找到匹配的内容，并且把匹配的内容返回
*exec捕获到结果的格式
*-&gt;获取的结果是数组
*-&gt;数组中的第一项是当前本次大正则在字符串中匹配的结果
*-&gt;index：记录了当前本次捕获到结果的起始索引
*-&gt;input:当前正则操作的原始字符串
*-&gt;如果当前正则中有分组，获取的数组中，从第二项开始都是小数组本次匹配到的结果（通过exec可以把分组中的内容捕获到）
*执行一次exec只能把符合正则规则条件中的一个内容捕获到，如果还有其他符合规则的，需要再次执行exec才有可能捕获到
*/
</code></pre>
<p>@2019-1-8</p>
<h5 id="正则捕获的懒惰型原理和解决方案">正则捕获的懒惰型原理和解决方案</h5>
<p><code>正则捕获存在懒惰型</code></p>
<blockquote>
<p>执行一次exec捕获到的第一个符合规则的内容，第二次执行exec，捕获到的依然是第一个匹配的内容，后面匹配的内容不管执行多少次exec都无法捕获到</p>
<p>解决正则捕获的懒惰型：</p>
<p>在正则的末尾加修饰符g（全局匹配）</p>
</blockquote>
<pre><code class="language-javascript">//=&gt;正则为什么会存在懒惰型？
//=&gt;正则本身有一个属性：lastIndex（下一次正则在字符串中匹配查找的开始索引）
//=&gt;默认值：0 从字符串第一个字符开始查找匹配的内容
//=&gt;默认不管执行多少遍exec方法，正则的lastIndex值都不会变（也就是第二次以后查找的时候还是从第一个字符查找，所以找到的结果永远都是第一个匹配的内容）
//=&gt;而且当我们手动把lastIndex进行修改的时候，不会起到任何的作用

//=&gt;为什么加修饰符g就解决了懒惰型?
//=&gt;加了修饰符g每一次exec结束后，浏览器默认会把lastIndex值进行修改，下一次从上一次结束的位置开始查找，所以可以得到后面匹配的内容了
</code></pre>
<h5 id="批量捕获正则匹配的内容">批量捕获正则匹配的内容</h5>
<blockquote>
<p>exec有自己的局限性：执行一次exec只能捕获到一个和正则匹配的结果（即使加了修饰符g），如果需要都捕获到，我们需要执行exec方法才可以</p>
<p>下面封装的myExecAll方法，目的是执行一次这个方法，可以把当前匹配到的全部内容都捕获到</p>
<pre><code class="language-javascript">RegExp.prototype.myExecAll = function myExecAll (){
	//=&gt;this:当前需要处理的正则
	//=&gt;str：当前需要处理的字符串
	var str = arguments[0]||'',
		result = [];
	var ary = this.exec(str);
	while(ary){

		//ary!==null :还可以捕获到内容，我们继续下一次捕获
		result.push(ary[0]);//=&gt;把当前本次捕获到的结果存放在RESULT数组中
		ary= this.exec(str);//=&gt;继续执行下一次的捕获
	}
	return result;


};

var reg = /\d+/g;
console.log(reg.myExecAll('珠峰培训2017扬帆起航2018'));
</code></pre>
<p>完善后，校验是否加g</p>
<pre><code class="language-javascript">RegExp.prototype.myExecAll = function myExecAll (){
	var str = arguments[0]||'',
		result = [];
	//=&gt;首先判断THIS是否加了全局修饰符g，如果没有加，为了防止下面执行出现死循环，我们只让其执行一次exec即可，把执行的结果返回即可
	if(!this.global) {
		return this.exec(str);
	}
	var ary = this.exec(str);
	while(ary){

		result.push(ary[0]);
		ary= this.exec(str);
	}
	return result;


};

var reg = /\d+/;
console.log(reg.myExecAll('珠峰培训2017扬帆起航2018'));
</code></pre>
</blockquote>
<h5 id="使用字符串中的match实现捕获">使用字符串中的match实现捕获</h5>
<pre><code class="language-javascript">var str = '珠峰培训2017扬帆起航2018杨帆2019起航2020';
var reg = /\d+/g;
str.match(reg);//=&gt;[&quot;2017&quot;, &quot;2018&quot;, &quot;2019&quot;, &quot;2020&quot;]
</code></pre>
<blockquote>
<p>使用字符串的match捕获：</p>
<ol>
<li>如果正则加了修饰符g，执行一次match会把所有正则匹配的内容捕获到</li>
<li>如果没有加修饰符g，执行一次match只能把第一个匹配的结果捕获到</li>
</ol>
<p>局限性：</p>
<p>在加了修饰符g的情况下，执行match方法只能把大正则匹配的内容捕获到，对于小分组捕获的内容方法给其自动忽略了</p>
<pre><code class="language-javascript">var str = 'my name is {0},i am {1} years old~,2017';
//=&gt;需求：把{n}整体捕获到，而且还要把括号中的数字也获取到
//var reg = /\{(\d+)\}/g;//=&gt;[&quot;{0}&quot;, &quot;{1}&quot;]

//=&gt;想要小分组中的内容，我们只能使用exec处理了
function fn(reg,str){
    var ary = reg.exec(str),
        result = [];
    while(ary){
        result.push(ary);
        ary = reg.exec(str);
    }
    return result;
}
</code></pre>
</blockquote>
<p>@2019-1-9</p>
<h5 id="使用test方法也可以实现正则的捕获">使用test方法也可以实现正则的捕获</h5>
]]></content>
    </entry>
</feed>